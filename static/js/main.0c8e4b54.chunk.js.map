{"version":3,"sources":["visualizer/GridNode.js","Algorithms/minHeap.js","Algorithms/dijkstra.js","Algorithms/aStar.js","visualizer/pathViz.js","App.js","serviceWorker.js","index.js"],"names":["React","memo","col","row","isFinish","isStart","isWall","isPath","toBeReset","onMouseUp","onMouseEnter","onMouseDown","nodeView","id","className","data-row","data-col","prevProps","nextProps","MinHeap","this","heapArray","size","node","dist","heapNode","push","A","B","temp","index","smallestDistLeft","smallestDistRight","leftVal","rightVal","swapHeapNode","heapify","root","lastNode","console","log","findIndex","key","parentIndex","Math","floor","getNeighbors","grid","neighbors","filter","neighbor","isVisited","aStar","startCoords","finishCoords","startRow","startCol","finishRow","finishCol","startNode","openList","closedList","startHeapNode","newHeapNode","addHeapNode","curr_row","Infinity","currNode","extractMin","prevNode","f","hueristic","decreaseKey","pop","shortestPath","currentRow","currentCol","backTrack","currCoords","abs","PathViz","useState","setGrid","instr","setInstr","setStartCoords","setFinishCoords","setisClicked","algo","setAlgo","slow","setSlow","isFinding","setisFinding","isReset","setisReset","createNode","gridInit","row_dim","col_dim","init_grid","newNode","handleClick","useCallback","e","currentTarget","dataset","prevInstr","prevGrid","updated_grid","slice","curr_node","new_node","parseInt","handleAlgoStart","visitedPath","path","heap","orderedVisitedNodes","closestNode","nodePart","distance","Dijkstra","speed","new_grid","i","length","thisNode","updateVisited","setTimeout","updatePath","pathNode","document","getElementById","handleWallSet","handleWallDrag","prevClick","wallGrid","useEffect","initial_grid","onClick","reset_grid","handleReset","disabled","map","rowIndex","nodeIndex","isVisualized","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.0c8e4b54.chunk.js","sourcesContent":["import React from 'react';\r\nimport './node.css';\r\n\r\nfunction Node({ col, row, isFinish, isStart, isWall, isPath, toBeReset, onMouseUp, onMouseEnter, onMouseDown }){\r\n    /*\r\n    Returns node component with corresponding properties\r\n    Args:\r\n    col, row: int: coordinates of the node\r\n    isFinish, isStart, isWall: bool: Indicates whether node is a start, finish or wall node\r\n    onClick, const: function to be called when node is clicked\r\n    */\r\n\r\n    //Set styling (Color) of node based on node type\r\n    const nodeView = isFinish ? 'node-finish' \r\n    : isStart ? 'node-start' \r\n    : isWall ? 'node-wall' \r\n    : isPath ? 'node-path' \r\n    : toBeReset ? 'node-temp' : 'node-plain'\r\n\r\n    //Render node\r\n    return(\r\n        <div id={`row-${row}col-${col}`}\r\n        className={nodeView}\r\n        onMouseUp={onMouseUp}\r\n        onMouseDown={onMouseDown}\r\n        onMouseEnter={onMouseEnter}\r\n        data-row={row}\r\n        data-col={col}>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nfunction areEqual(prevProps, nextProps){\r\n    //If no props have changed, prevent rendering of node\r\n\r\n    if (prevProps.toBeReset === nextProps.toBeReset && prevProps.row === nextProps.row && prevProps.col === nextProps.col && prevProps.isFinish === nextProps.isFinish &&prevProps.isStart === nextProps.isStart &&prevProps.isWall === nextProps.isWall &&prevProps.isPath === nextProps.isPath && prevProps.onMouseUp===nextProps.onMouseUp && prevProps.onMouseEnter===nextProps.onMouseEnter && prevProps.onMouseDown===nextProps.onMouseDown){\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport default React.memo(Node, areEqual);\r\n","\r\nexport default class MinHeap{\r\n    /*\r\n    Defines object minHeap to be implemented in Djikstra's algorithm\r\n    */\r\n\r\n    //Initialize size of heap and corresponding array\r\n    constructor(){\r\n        this.heapArray = []; // hold nodes in list, each node is an object with props {vertex, distance}\r\n        this.size = 0; //tracks the size of minheap (number of unvistied nodes remaining)\r\n    }\r\n\r\n    newHeapNode(node, dist){\r\n        /*\r\n        Create a new node array with vertex and distance properties\r\n        Args:\r\n        node, node: A node object\r\n        dist, int: The distance from this node to the start node\r\n        This will be initialized as infinity for all nodes other than start\r\n        \r\n        Returns:\r\n        heapNode: a node object to be placed in the minheap\r\n        */\r\n        let heapNode = [node, dist];\r\n        return heapNode\r\n    }\r\n\r\n    addHeapNode(heapNode){\r\n        //Adds given heapNode to the heap array\r\n        this.heapArray.push(heapNode);\r\n        this.size += 1;\r\n    }\r\n\r\n    swapHeapNode(A, B){\r\n        /*\r\n        Swaps the location of two nodes in the heap array\r\n        Args:\r\n        nodeA, nodeB: int: Array location of first and second node to be swapped\r\n        Returns: Node\r\n        */\r\n        //Store first node in temporary variable\r\n        const temp = this.heapArray[A];\r\n\r\n        //Swap nodes in heap array\r\n        this.heapArray[A] = this.heapArray[B];\r\n        this.heapArray[B] = temp;\r\n    }\r\n\r\n    heapify(index){\r\n        /*\r\n        Manipulates heap until it meets the heap-order property of a minheap. Continually swaps\r\n        parent and child values until condition is satisfied\r\n        Args:\r\n        index, int: The index to start the comparisons, usually 0\r\n        */\r\n\r\n        //Initially assume that the smallest distance is at the given index (0 unless being called recursively)\r\n        let smallestDistLeft = index;\r\n        let smallestDistRight = index;\r\n\r\n        //Calculate value of left and right child nodes\r\n        let leftVal = 2*index + 1;\r\n        let rightVal = 2*index + 2;\r\n\r\n        //If the left child is defined, and the distance at the left child is less than the parent\r\n        if (leftVal < this.size && this.heapArray[leftVal][1] < this.heapArray[smallestDistLeft][1]){\r\n            //Set smallest distance value to the distance at the left child\r\n            smallestDistLeft = leftVal;\r\n        }\r\n\r\n        //If smallest distance value was changed above^ (If child node values were less than parent)\r\n        if(smallestDistLeft !== index){\r\n            \r\n            //swap distance values of child and parent with swapHeapNode() method\r\n            this.swapHeapNode(smallestDistLeft, index)\r\n\r\n            //Recursively execute until heap meets heap-order property of min-heap\r\n            this.heapify(smallestDistLeft)\r\n        }\r\n\r\n        //Repeat with right child\r\n        if (rightVal < this.size && this.heapArray[rightVal][1] < this.heapArray[smallestDistRight][1]){\r\n            smallestDistRight = rightVal;\r\n        }\r\n\r\n        //If smallest distance value was changed above^ (If child node values were less than parent)\r\n        if(smallestDistRight !== index){\r\n            \r\n            //swap distance values of child and parent with swapHeapNode() method\r\n            this.swapHeapNode(smallestDistRight, index)\r\n\r\n            //Recursively execute until heap meets heap-order property of min-heap\r\n            this.heapify(smallestDistRight)\r\n        }\r\n    }\r\n\r\n    extractMin(){\r\n        /*\r\n        Extracts the node of minumum distance from heap\r\n        */           \r\n     \r\n        //if min heap is empty, return null\r\n        if(this.size === 0){\r\n            return null;\r\n        }\r\n        //get root node from heap array\r\n        let root = this.heapArray[0];\r\n\r\n        //Get last node in heap array and place it at the start of the array\r\n        const lastNode = this.heapArray[this.size -1];\r\n        this.heapArray[0] = lastNode;\r\n\r\n     \r\n\r\n        //Decrease size of heap by 1\r\n        this.size -= 1;\r\n        //Call heapify() to re-organize array to fit minheap requirements\r\n        this.heapify(0);\r\n        \r\n        //Return the new root value\r\n        return root;\r\n    }\r\n\r\n    decreaseKey(node, dist){\r\n\r\n        //Find location of given node in heap array\r\n        console.log(node)\r\n        let index = this.heapArray.findIndex((key) => (key[0].row === node.row && key[0].col === node.col));  \r\n\r\n        //Find index of parent using minheap property\r\n        let parentIndex = Math.floor((index-1)/2);\r\n\r\n        //Update distance value of given node\r\n        this.heapArray[index][1] = dist;\r\n\r\n        //If the new value is less than its parent, continually swap with parent until heap-order consition is met\r\n        while(index > 0 && this.heapArray[index][1] < this.heapArray[parentIndex][1]){\r\n\r\n            //Swap both nodes in heap array\r\n            this.swapHeapNode(index, parentIndex)\r\n\r\n            //Set the index to the parent index to check for failed condition again at top of loop\r\n            index = parentIndex;\r\n            parentIndex = Math.floor((index-1)/2);\r\n        }    \r\n    }\r\n\r\n/*\r\n    isInHeap(vertex){\r\n        \r\n        //If the given vertex is in the heap, return true. False otherwise\r\n        \r\n        if(this.pos(vertex) < this.size){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    \r\n    addNode(newNode){\r\n\r\n    }\r\n    */\r\n\r\n\r\n\r\n}","import MinHeap from './minHeap'\r\n\r\n//TODO: Deal with tracking rows and columns of nodes within minheap ( or outside)\r\n\r\nexport function Dijkstra(grid, startCoords, finishCoords){\r\n\r\n    //Decompose start and finish coordinates\r\n    const startRow = startCoords[0];\r\n    const startCol = startCoords[1];\r\n    const finishRow = finishCoords[0];\r\n    const finishCol = finishCoords[1];\r\n\r\n    // Create instance of minheap \r\n    let heap = new MinHeap();\r\n\r\n    //Create array to track visited nodes in order of visitation\r\n    let orderedVisitedNodes = [];\r\n\r\n    //Get the node objects for the start node and end node\r\n    const startNode = grid[startRow][startCol];  \r\n\r\n\r\n    //Create new heap Node for starting node(see attributes in minHeap class), and add this node to heap array with distance of 0\r\n    const startHeapNode = heap.newHeapNode(startNode, 0);\r\n    heap.addHeapNode(startHeapNode);\r\n\r\n    //Initialize Minheap\r\n    for(const curr_row of grid){\r\n        for(const node of curr_row){\r\n            //Start node has already been added to heap, so skip this iteration\r\n            if(node.row === startRow && node.col === startCol){\r\n                continue;\r\n            }\r\n            //Add node to the heap array\r\n            let heapNode = heap.newHeapNode(node, Infinity);\r\n            heap.addHeapNode(heapNode);     \r\n        }\r\n    }\r\n\r\n    //run algorithm while minheap still has nodes \r\n    //(break when finsh node is found)\r\n    while(heap.size !== 0){\r\n\r\n        //Get nearest node and decompose into node part and distance value\r\n        let closestNode = heap.extractMin(); //returns [node,distance]\r\n        let nodePart = closestNode[0];\r\n        const distance = closestNode[1];\r\n        \r\n\r\n        //Create isVisited property and set it to true\r\n        nodePart.isVisited = true;\r\n\r\n        //Add this node to array of visited nodes\r\n        orderedVisitedNodes.push(nodePart);\r\n\r\n        //If closest node is the finish node, stop algorithm\r\n        if(nodePart.row === finishRow && nodePart.col === finishCol){\r\n            break;\r\n        } \r\n        \r\n        //get the unvisited neighbors of current node (up, down, left, right)\r\n        let neighbors = getNeighbors(grid, nodePart);\r\n\r\n\r\n        //For each unvisited neighbor, set its distance to the current distance + 1\r\n        for(const neighbor of neighbors){\r\n            neighbor.prevNode = nodePart\r\n            heap.decreaseKey(neighbor, distance + 1);  \r\n        }\r\n\r\n\r\n    }\r\n    //Get last node visited (finish node)\r\n    const lastNode = orderedVisitedNodes.pop();\r\n    //Get shortest path from backTrack() function\r\n    const shortestPath = backTrack(lastNode, startRow, startCol);\r\n    //Once algorithm has finished, return shortest path from finish to start\r\n    return ([orderedVisitedNodes, shortestPath])   \r\n    \r\n\r\n}\r\n\r\nfunction getNeighbors(grid, node){\r\n    /*\r\n    Gets the four neighbors surrounding a node (up,down,left,right) which are unvisited\r\n    Args:\r\n    grid, Array: The grid of nodes\r\n    node, Node: The node whose neighbors will be returned\r\n    Returns:\r\n    neighbors: Array of all unvisited neighbor nodes \r\n    */\r\n\r\n    //Initialize neighbors as empty array\r\n    let neighbors = [];\r\n    //Get coordinates of node\r\n    const [row, col] = [node.row, node.col];\r\n\r\n    //If neighbor is on board, append to neighbors array\r\n    if (row<24){neighbors.push(grid[row+1][col])};\r\n    if (row>0){neighbors.push(grid[row-1][col])};\r\n    if (col<59){neighbors.push(grid[row][col+1])};\r\n    if (col>0) {neighbors.push(grid[row][col-1])};\r\n    //console.log(neighbors)\r\n    \r\n    //Remove neighbors which are walls\r\n    let filteredNeighbors = neighbors.filter(neighbor => !neighbor.isWall)\r\n\r\n    //Return all neighbors that haven't already been visited\r\n    return filteredNeighbors.filter(neighbor => !neighbor.isVisited)\r\n}\r\n\r\nexport function backTrack(lastNode, startRow, startCol){\r\n    //Initialize shortest path as empty array\r\n    const shortestPath = [];\r\n\r\n    //Current node starts as the finish node\r\n    let currNode = lastNode\r\n\r\n    //Get coordinates of finish node\r\n    let currentRow = lastNode.row;\r\n    let currentCol = lastNode.col;\r\n\r\n    //Append finish node to shortest path\r\n    shortestPath.push(currNode);\r\n\r\n    //Append each node to shortest path until start node is reached\r\n    while(currentRow !== startRow || currentCol !== startCol){\r\n        //Get previous node\r\n        currNode = currNode.prevNode\r\n        //Reset current coordinates to those of previous node\r\n        currentRow = currNode.row;\r\n        currentCol = currNode.col;\r\n        //Append previoud node to shortest path\r\n        shortestPath.push(currNode);\r\n    }\r\n    //Return shortest path form finish to start\r\n    return shortestPath;\r\n}\r\n","import MinHeap from './minHeap'\r\n\r\nexport default function aStar(grid, startCoords, finishCoords){\r\n\r\n    //Get row and column of the start node and finish node\r\n    const startRow = startCoords[0];\r\n    const startCol = startCoords[1];\r\n    const finishRow = finishCoords[0];\r\n    const finishCol = finishCoords[1];\r\n\r\n    //Get the start and finish node objects from grid\r\n    let startNode = grid[startRow][startCol];\r\n\r\n    //Initialize open list and closed list, \r\n    //open list is minheap of nodes to be visited, closed list is nodes that have already been visited\r\n    let openList = new MinHeap();\r\n\r\n    //open list is list of nodes to be visited, closed list is nodes that have alreadt been visited\r\n    let closedList = [];\r\n\r\n    //Create new heap Node for starting node(see attributes in minHeap class), and add this node to heap array with distance of 0\r\n    const startHeapNode = openList.newHeapNode(startNode, 0);\r\n    openList.addHeapNode(startHeapNode);\r\n\r\n    //Initialize Minheap\r\n    for(const curr_row of grid){\r\n        for(const node of curr_row){\r\n            //Start node has already been added to heap, so skip this iteration\r\n            if(node.row === startRow && node.col === startCol){\r\n                continue;\r\n            }\r\n            //Add node to the heap array\r\n            let heapNode = openList.newHeapNode(node, Infinity);\r\n            openList.addHeapNode(heapNode);     \r\n        }\r\n    }\r\n\r\n    //Continually search until openList is empty or finish point is found\r\n    while (openList.size !== 0){\r\n\r\n        //Set the current node to the first node in open list, and mark this node as visited\r\n        let closestNode = openList.extractMin(); //Returns [node, f] \r\n        let currNode = closestNode[0];\r\n        currNode.isVisited = true;\r\n\r\n        //Add current node to closed list\r\n        closedList.push(currNode)\r\n\r\n        //If the finish node has been found, break out of loop\r\n        if (currNode.row === finishRow && currNode.col === finishCol){\r\n            break;\r\n        }\r\n\r\n        //Get neighbors of the current node\r\n        let neighbors = getNeighbors(grid, currNode);\r\n        \r\n        //for each neighbor, calculate its value and add to open list\r\n        for(const neighbor of neighbors){\r\n            \r\n            // assign the current node as the previous node of the neighbor node\r\n            neighbor.prevNode = currNode;\r\n            const neighborCoords = [neighbor.row, neighbor.col];\r\n\r\n            //Calculate the Manhattan heuristic of the neighbor \r\n            const h = hueristic(neighborCoords, finishCoords);\r\n            const f = 1 + h;\r\n\r\n            //Change f value for neighbor in openList(minHeap)\r\n            openList.decreaseKey(neighbor, f)\r\n        }\r\n    }\r\n\r\n    //Once loop has finished, find the shortest path with backtrack\r\n    const lastNode = closedList.pop();\r\n    const shortestPath = backTrack(lastNode, startRow, startCol);\r\n\r\n    //Return the list of visited nodes in order (closed list) and the shortest path\r\n    return ([closedList, shortestPath])   \r\n\r\n\r\n}\r\n\r\nfunction hueristic(currCoords, finishCoords){\r\n    //Implement Manhattan hueristic\r\n\r\n    const h = Math.abs(currCoords[0] - finishCoords[0]) + Math.abs(currCoords[1] - finishCoords[1]);\r\n    return h;\r\n\r\n}\r\n\r\nfunction getNeighbors(grid, currNode){\r\n    //Return all eligbile neighbors of given node\r\n    let neighbors = [];\r\n    const [row, col] = [currNode.row, currNode.col];\r\n\r\n    //If neighbor is on board, append to neighbors array\r\n    if (row<24){neighbors.push(grid[row+1][col])};\r\n    if (row>0){neighbors.push(grid[row-1][col])};\r\n    if (col<59){neighbors.push(grid[row][col+1])};\r\n    if (col>0) {neighbors.push(grid[row][col-1])};\r\n\r\n    console.log(neighbors)\r\n\r\n    //Add filter for nodes already visited? Or is this solved by closed list??\r\n\r\n    //Remove neighbors which are walls\r\n    let filteredNeighbors = neighbors.filter(neighbor => !neighbor.isWall)\r\n\r\n    //Return all neighbors that haven't already been visited\r\n    //console.log(neighbors)\r\n    return filteredNeighbors.filter(neighbor => (!neighbor.isVisited && !neighbor.isStart))\r\n\r\n}\r\n\r\nexport function backTrack(lastNode, startRow, startCol){\r\n    //Initialize shortest path as empty array\r\n    const shortestPath = [];\r\n\r\n    //Current node starts as the finish node\r\n    let currNode = lastNode\r\n\r\n    //Get coordinates of finish node\r\n    let currentRow = lastNode.row;\r\n    let currentCol = lastNode.col;\r\n\r\n    //Append finish node to shortest path\r\n    shortestPath.push(currNode);\r\n\r\n    //Append each node to shortest path until start node is reached\r\n    while(currentRow !== startRow || currentCol !== startCol){\r\n        //Get previous node\r\n        currNode = currNode.prevNode\r\n        //Reset current coordinates to those of previous node\r\n        currentRow = currNode.row;\r\n        currentCol = currNode.col;\r\n        //Append previoud node to shortest path\r\n        shortestPath.push(currNode);\r\n    }\r\n    //Return shortest path form finish to start\r\n    return shortestPath;\r\n}","import React, { useState, useEffect, useCallback } from 'react';\r\nimport Node from './GridNode';\r\nimport './pathViz.css';\r\nimport Options from './menu/options'\r\nimport { Dijkstra } from '../Algorithms/dijkstra';\r\nimport aStar  from '../Algorithms/aStar';\r\n\r\n\r\n//TODO: Add functionality for user to choose algorithm\r\n//TODO: edit readme and correct comment typos\r\n\r\nexport default function PathViz(){\r\n/*\r\nFunctional component which displays the entire Path visualizer\r\n*/\r\n\r\n//Initialize various state variables to be updated\r\n    const [grid, setGrid] = useState([]); //Grid to be displayed\r\n\r\n    //Tracks which instruction the next mouse click will perform\r\n    const [instr, setInstr] = useState(\"Start Point\")\r\n\r\n    //Tracks start and finish coordinates\r\n    const [startCoords, setStartCoords] = useState({});\r\n    const [finishCoords, setFinishCoords] = useState([]);\r\n\r\n    //Track if mouse is currently pressed\r\n    const [isClicked, setisClicked] = useState(false);\r\n\r\n    //Track algorithm to be used\r\n    const [algo, setAlgo] = useState(\"Dijkstra\")\r\n    const [slow, setSlow] = useState(false)\r\n\r\n    const [isFinding, setisFinding] = useState(false)\r\n    const [isReset, setisReset] = useState(true)\r\n\r\n\r\n    const createNode = (col, row) => {\r\n        /*\r\n        Returns an object with the properties for a blank node\r\n        */\r\n        return(\r\n            {\r\n            col, \r\n            row, \r\n            isStart: false, \r\n            isFinish: false, \r\n            isWall: false,\r\n            //isVisited: false,\r\n            toBeReset: false\r\n            }\r\n        )\r\n    }\r\n\r\n    const gridInit = (row_dim, col_dim) => {\r\n        /*\r\n        Creates a blank grid with the given dimensions\r\n        Args:\r\n        row_dim, int: Specifies number of rows to be created on grid\r\n        col_dim, int: Specifies number of columns to be created on grid\r\n\r\n        Returns:\r\n        init_grid, array: An r x c array with plain nodes in each element\r\n        */\r\n\r\n        //Initialize grid as empty array\r\n        const init_grid = [];\r\n\r\n        //Create the grid one row at a time\r\n        for (let row = 0; row < row_dim; row++){\r\n\r\n            //Initialize current row as empty array\r\n            const curr_row = [];\r\n\r\n            //Append new nodes to the current row\r\n            for ( let col = 0; col < col_dim; col++){\r\n                const newNode = createNode(col,row);\r\n                curr_row.push(newNode);\r\n            }\r\n            //Append current row to grid\r\n            init_grid.push(curr_row); \r\n        }\r\n        return init_grid;\r\n    };\r\n\r\n    const handleClick = useCallback(function handleClick(e){\r\n        /*\r\n        Updates the grid when a node is clicked based on the current state\r\n        Args:\r\n        row,col: int: coordinates of node which was clicked\r\n        Returns: None\r\n        */\r\n\r\n        //Get coordinates of node clicked from event dataset\r\n       const row = e.currentTarget.dataset[\"row\"];\r\n       const col = e.currentTarget.dataset[\"col\"];\r\n          \r\n       //Execute code nested in setInstr in order to avoid handleClick updating and re-rendering all nodes\r\n        setInstr((prevInstr) => {\r\n            //If the previous instruction is start point\r\n            if (prevInstr === \"Start Point\") {\r\n                //Update grid with new start point\r\n                setGrid( (prevGrid) => {\r\n                    const updated_grid = prevGrid.slice();\r\n    \r\n                    //Get the current node at the given location\r\n                    const curr_node = updated_grid[row][col];\r\n    \r\n                    //Toggle isStartset for the current node\r\n                    const new_node = {...curr_node, isStart:true};\r\n    \r\n                    //Assign this new node to the correct location\r\n                    updated_grid[row][col] = new_node;\r\n                    return updated_grid\r\n                })\r\n                //Set start coords with position of current node\r\n                setStartCoords(() => {\r\n                    return [parseInt(row), parseInt(col)]\r\n                });\r\n                //Set state of mouse to not clicked\r\n                setisClicked(false)\r\n                //Update instruction to \"finish point\"\r\n                return (\"Finish Point\")\r\n            }\r\n            //If the start was already set\r\n            else if (prevInstr === \"Finish Point\"){\r\n                   \r\n                //Update state of grid, isClicked and finish coordinates\r\n                setGrid( (prevGrid) => {\r\n                    const updated_grid = prevGrid.slice();\r\n    \r\n                    //Get the current node at the given location\r\n                    const curr_node = updated_grid[row][col];\r\n    \r\n                    //Toggle isStartset for the current node\r\n                    const new_node = {...curr_node, isFinish:true};\r\n    \r\n                    //Assign this new node to the correct location\r\n                    updated_grid[row][col] = new_node;\r\n                    return updated_grid\r\n                })\r\n               //Set finish coords with coords of clicked node      \r\n                setFinishCoords(() => {\r\n                    return [parseInt(row), parseInt(col)]\r\n                });\r\n                //Set is clicked to false\r\n                setisClicked(false)\r\n                //Return new instruction as walls\r\n                return (\"Walls\")\r\n            }\r\n            else{\r\n                setisClicked(false)\r\n                return prevInstr\r\n            }\r\n        })\r\n    }, [])\r\n\r\n    const handleReset = () => {\r\n        /*\r\n        Resets the grid \r\n        */ \r\n\r\n       //Create new blank grid with gridInit() method.\r\n        const reset_grid = gridInit(25,60);\r\n\r\n        //Update states accordingly\r\n        setisReset(true)\r\n        setGrid(reset_grid);\r\n        setInstr(\"Start Point\")\r\n    }\r\n\r\n    const handleAlgoStart = () => {\r\n        /*\r\n        Start the algorithm and update the grid with the new path\r\n        */\r\n        //const [visitedPath, path] = Dijkstra(grid, startCoords, finishCoords);\r\n\r\n        setisFinding(true)\r\n        setisReset(false)\r\n\r\n        let [visitedPath, path] = [[], []];\r\n        switch(algo){\r\n            case \"Dijkstra\":\r\n                [visitedPath, path] = Dijkstra(grid, startCoords, finishCoords);\r\n                break;\r\n            case \"aStar\":\r\n                [visitedPath, path] = aStar(grid, startCoords, finishCoords);\r\n                break;\r\n            default: [visitedPath, path] = aStar(grid, startCoords, finishCoords);\r\n\r\n        }\r\n\r\n        let speed = 15;\r\n        switch(slow){\r\n            case true:\r\n                speed = 100\r\n                break;\r\n            case false:\r\n                speed = 15\r\n                break;\r\n            default:\r\n                speed = 15;\r\n        }\r\n\r\n        let new_grid = grid.slice();\r\n        //Update the each node visited by Djikstra's algorithm\r\n        for(let i = 1; i < visitedPath.length; i++){\r\n            const thisNode = visitedPath[i];\r\n            //Update each node with an asyncronous call every 10 ms (See updateVisited())\r\n            updateVisited(thisNode, i, speed)\r\n\r\n            //Update new_grid, to be used to update state\r\n            const row = thisNode.row;\r\n            const col = thisNode.col;\r\n            let curr_node = new_grid[row][col]\r\n            const new_node = {...curr_node, toBeReset:!curr_node.toBeReset};\r\n            new_grid[row][col] = new_node\r\n        }\r\n\r\n\r\n        // Update the path as soon as the animation has finished\r\n        setTimeout( () => {\r\n            updatePath(path)\r\n            setisFinding(false)\r\n        }, speed * visitedPath.length, path)\r\n\r\n        //Update the grid, this takes place before most of the animations \r\n        setGrid(new_grid)\r\n    }\r\n\r\n    const updatePath = (path) => {\r\n        //Update the path by creating a new grid and updating state\r\n        let new_grid = grid.slice();\r\n        for (let i = 0; i < path.length; i++){\r\n            const thisNode = path[i];\r\n            const row = thisNode.row;\r\n            const col = thisNode.col;\r\n            let curr_node = new_grid[row][col]\r\n            const new_node = {...curr_node, isPath:!curr_node.isPath};\r\n            new_grid[row][col] = new_node\r\n        }\r\n        setGrid(new_grid)\r\n    }      \r\n\r\n\r\n    const updateVisited = (pathNode, i, speed) => {\r\n        //Animate visited nodes every 10 ms\r\n\r\n        const row = pathNode.row;\r\n        const col = pathNode.col;\r\n        \r\n        setTimeout( () => {\r\n            document.getElementById(`row-${row}col-${col}`).className='node-visited'\r\n        }, speed*i, row, col)  \r\n    }\r\n\r\n    const handleWallSet = useCallback( function handleWallSet(e){\r\n        //Set status of mouse click to true\r\n        setisClicked(() => {\r\n            return true\r\n        });\r\n        //Call handleWallDrag to ensure the initial clicked node also is set as wall\r\n        handleWallDrag(e)\r\n    },[])\r\n\r\n    const handleWallDrag = useCallback( function handleWallDrag(e){\r\n        /*\r\n        Set walls on grid given the current state of the grid and mouse click\r\n        */\r\n\r\n        //Get coordinates of node entered with synthetic event\r\n        const row = e.currentTarget.dataset[\"row\"];\r\n        const col = e.currentTarget.dataset[\"col\"];\r\n        \r\n        //Nest all operations within setisClicked and setInstr in order to check those states\r\n        setisClicked( (prevClick) => {\r\n            //If the mouse is pressed\r\n            if (prevClick){\r\n                //Check if instruction is set to walls\r\n                setInstr( (prevInstr) => {\r\n                    if (prevInstr===\"Walls\"){\r\n                        //If walls are being set, set current node to a wall and update grid\r\n                        setGrid((prevGrid) => {\r\n                            const wallGrid = prevGrid.slice();\r\n                            const curr_node = wallGrid[row][col];\r\n                            const new_node = {...curr_node, isWall:true};\r\n                            wallGrid[row][col] = new_node;\r\n                            return wallGrid\r\n                        });\r\n                    }   \r\n                    //Return the same instruction as before, should only be reset with reset button                 \r\n                    return prevInstr\r\n                })\r\n                //Return mouse clicked as true\r\n                return true\r\n            }\r\n            //If mouse isn't pressed down, return previous instruction\r\n            else{\r\n                setInstr(prevInstr => {\r\n                    return prevInstr\r\n                })\r\n            }\r\n            //Always return mouse clicked as same value as previous state\r\n            return prevClick\r\n        })\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        /*\r\n        Updates the grid at the initial DOM render\r\n        Similar to componentdidMount() with React class component\r\n        */\r\n        const initial_grid = gridInit(25,60);\r\n        setGrid(initial_grid);\r\n    },[]); //rendered on only initial render because of empty array dependency\r\n\r\n    //Component rendering\r\n    return(\r\n        <div>\r\n        <div className=\"menu\">\r\n            <div className=\"options\">\r\n                <button className=\"algoButton\" onClick = {() => setAlgo(\"Dijkstra\")}>\r\n                    Dijkstra's Algorithm\r\n                </button>\r\n                <button className=\"algoButton\" onClick = {() => setAlgo(\"aStar\")}>\r\n                    A * Search\r\n                </button>\r\n            </div>\r\n                \r\n            \r\n        </div>\r\n\r\n\r\n        <div className=\"grid\">\r\n            <text className=\"instructions\">Set {instr}</text>\r\n\r\n\r\n            <div className=\"options\">\r\n\r\n                <button className=\"reset\" onClick={() => handleReset()} disabled={isFinding}>\r\n                        Reset\r\n                    </button>\r\n                <button className=\"start\" onClick={() => handleAlgoStart()} disabled={(!isReset || instr ===\"Start Point\" || instr ===\"Finish Point\")}>\r\n                        Start {algo}\r\n                    </button>\r\n                <button className=\"reset\" onClick={ () => setSlow(!slow)} disabled={isFinding}>\r\n                    Turn on {slow ? \"fast\" : \"slow\"} mode\r\n                </button>\r\n            </div>\r\n            \r\n            {grid.map( (row, rowIndex) => {\r\n                return(\r\n                    <div className=\"row\" key={rowIndex}>\r\n                        {row.map( (node, nodeIndex) => {\r\n                            const {col, row, isFinish, isStart, isWall, isPath, isVisualized, toBeReset} = node;\r\n                            return(\r\n                                <div key={nodeIndex} >\r\n                                    <Node \r\n                                        col = {col}\r\n                                        row = {row}\r\n                                        isFinish = {isFinish}\r\n                                        isStart = {isStart}\r\n                                        isWall = {isWall}\r\n                                        isPath = {isPath}\r\n                                        toBeReset = {toBeReset}\r\n                                        isVisualized = {isVisualized}\r\n                                        onMouseUp = {handleClick}\r\n                                        onMouseDown = {handleWallSet}\r\n                                        onMouseEnter = {handleWallDrag}\r\n                                    ></Node>\r\n                                </div>\r\n                            );\r\n                        })}\r\n                    </div>\r\n                );\r\n            }\r\n        )}\r\n        </div>\r\n        </div>\r\n    )\r\n}","import React, { useState } from 'react';\nimport './App.css';\nimport PathViz from './visualizer/pathViz';\n\nfunction App() {\n\n  return (\n    <div className=\"App\">\n      <PathViz></PathViz>\n    </div>\n  ); \n}\n \nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}