{"version":3,"sources":["visualizer/GridNode.js","Algorithms/minHeap.js","Algorithms/dijkstra.js","Algorithms/aStar.js","visualizer/pathViz.js","App.js","serviceWorker.js","index.js"],"names":["React","memo","col","row","isFinish","isStart","isWall","isPath","toBeReset","onMouseUp","onMouseEnter","onMouseDown","isVisited","nodeView","id","className","data-row","data-col","prevProps","nextProps","MinHeap","this","heapArray","size","node","dist","heapNode","push","A","B","temp","index","smallestDistLeft","smallestDistRight","leftVal","rightVal","swapHeapNode","heapify","root","lastNode","console","log","findIndex","key","parentIndex","Math","floor","getNeighbors","grid","neighbors","filter","neighbor","aStar","startCoords","finishCoords","startRow","startCol","finishRow","finishCol","startNode","openList","closedList","startHeapNode","newHeapNode","addHeapNode","curr_row","Infinity","currNode","extractMin","prevNode","f","hueristic","decreaseKey","pop","shortestPath","currentRow","currentCol","backTrack","currCoords","abs","PathViz","useState","setGrid","instr","setInstr","setStartCoords","setFinishCoords","setisClicked","algo","setAlgo","speed","setSpeed","isFinding","setisFinding","isReset","setisReset","createNode","gridInit","row_dim","col_dim","init_grid","newNode","handleClick","useCallback","e","currentTarget","dataset","prevInstr","prevGrid","updated_grid","slice","curr_node","new_node","parseInt","handleAlgoStart","visitedPath","path","heap","orderedVisitedNodes","closestNode","nodePart","distance","Dijkstra","animateTime","new_grid","i","length","thisNode","updateVisited","setTimeout","updatePath","pathNode","document","getElementById","handleWallSet","handleWallDrag","prevClick","wallGrid","useEffect","initial_grid","style","fontWeight","background","fontSize","onClick","disabled","reset_grid","handleReset","GridNode","map","rowIndex","nodeIndex","isVisualized","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.58356a83.chunk.js","sourcesContent":["import React from 'react';\r\nimport './node.css';\r\n\r\nfunction Node({ col, row, isFinish, isStart, isWall, isPath, toBeReset, onMouseUp, onMouseEnter, onMouseDown, isVisited }){\r\n    /*\r\n    Returns node component with corresponding properties\r\n    Args:\r\n    col, row: int: coordinates of the node\r\n    isFinish, isStart, isWall: bool: Indicates whether node is a start, finish or wall node\r\n    onClick, const: function to be called when node is clicked\r\n    */\r\n\r\n    //Set styling (Color) of node based on node type\r\n    const nodeView = isFinish ? 'node-finish' \r\n    : isStart ? 'node-start' \r\n    : isWall ? 'node-wall' \r\n    : isPath ? 'node-path' \r\n    : isVisited ? 'node-visited'\r\n    : toBeReset ? 'node-temp' : 'node-plain'\r\n\r\n    //Render node\r\n    return(\r\n        <div id={`row-${row}col-${col}`}\r\n        className={nodeView}\r\n        onMouseUp={onMouseUp}\r\n        onMouseDown={onMouseDown}\r\n        onMouseEnter={onMouseEnter}\r\n        data-row={row}\r\n        data-col={col}>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nfunction areEqual(prevProps, nextProps){\r\n    //If no props have changed, prevent rendering of node\r\n\r\n    if (prevProps.toBeReset === nextProps.toBeReset && prevProps.row === nextProps.row && prevProps.col === nextProps.col && prevProps.isFinish === nextProps.isFinish &&prevProps.isStart === nextProps.isStart &&prevProps.isWall === nextProps.isWall &&prevProps.isPath === nextProps.isPath && prevProps.onMouseUp===nextProps.onMouseUp && prevProps.onMouseEnter===nextProps.onMouseEnter && prevProps.onMouseDown===nextProps.onMouseDown){\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport default React.memo(Node, areEqual);\r\n","\r\nexport default class MinHeap{\r\n    /*\r\n    Defines object minHeap to be implemented in Djikstra's algorithm\r\n    */\r\n\r\n    //Initialize size of heap and corresponding array\r\n    constructor(){\r\n        this.heapArray = []; // hold nodes in list, each node is an object with props {vertex, distance}\r\n        this.size = 0; //tracks the size of minheap (number of unvistied nodes remaining)\r\n    }\r\n\r\n    newHeapNode(node, dist){\r\n        /*\r\n        Create a new node array with vertex and distance properties\r\n        Args:\r\n        node, node: A node object\r\n        dist, int: The distance from this node to the start node\r\n        This will be initialized as infinity for all nodes other than start\r\n        \r\n        Returns:\r\n        heapNode: a node object to be placed in the minheap\r\n        */\r\n        let heapNode = [node, dist];\r\n        return heapNode\r\n    }\r\n\r\n    addHeapNode(heapNode){\r\n        //Adds given heapNode to the heap array\r\n        this.heapArray.push(heapNode);\r\n        this.size += 1;\r\n    }\r\n\r\n    swapHeapNode(A, B){\r\n        /*\r\n        Swaps the location of two nodes in the heap array\r\n        Args:\r\n        nodeA, nodeB: int: Array location of first and second node to be swapped\r\n        Returns: Node\r\n        */\r\n        //Store first node in temporary variable\r\n        const temp = this.heapArray[A];\r\n\r\n        //Swap nodes in heap array\r\n        this.heapArray[A] = this.heapArray[B];\r\n        this.heapArray[B] = temp;\r\n    }\r\n\r\n    heapify(index){\r\n        /*\r\n        Manipulates heap until it meets the heap-order property of a minheap. Continually swaps\r\n        parent and child values until condition is satisfied\r\n        Args:\r\n        index, int: The index to start the comparisons, usually 0\r\n        */\r\n\r\n        //Initially assume that the smallest distance is at the given index (0 unless being called recursively)\r\n        let smallestDistLeft = index;\r\n        let smallestDistRight = index;\r\n\r\n        //Calculate value of left and right child nodes\r\n        let leftVal = 2*index + 1;\r\n        let rightVal = 2*index + 2;\r\n\r\n        //If the left child is defined, and the distance at the left child is less than the parent\r\n        if (leftVal < this.size && this.heapArray[leftVal][1] < this.heapArray[smallestDistLeft][1]){\r\n            //Set smallest distance value to the distance at the left child\r\n            smallestDistLeft = leftVal;\r\n        }\r\n\r\n        //If smallest distance value was changed above^ (If child node values were less than parent)\r\n        if(smallestDistLeft !== index){\r\n            \r\n            //swap distance values of child and parent with swapHeapNode() method\r\n            this.swapHeapNode(smallestDistLeft, index)\r\n\r\n            //Recursively execute until heap meets heap-order property of min-heap\r\n            this.heapify(smallestDistLeft)\r\n        }\r\n\r\n        //Repeat with right child\r\n        if (rightVal < this.size && this.heapArray[rightVal][1] < this.heapArray[smallestDistRight][1]){\r\n            smallestDistRight = rightVal;\r\n        }\r\n\r\n        //If smallest distance value was changed above^ (If child node values were less than parent)\r\n        if(smallestDistRight !== index){\r\n            \r\n            //swap distance values of child and parent with swapHeapNode() method\r\n            this.swapHeapNode(smallestDistRight, index)\r\n\r\n            //Recursively execute until heap meets heap-order property of min-heap\r\n            this.heapify(smallestDistRight)\r\n        }\r\n    }\r\n\r\n    extractMin(){\r\n        /*\r\n        Extracts the node of minumum distance from heap\r\n        */           \r\n     \r\n        //if min heap is empty, return null\r\n        if(this.size === 0){\r\n            return null;\r\n        }\r\n        //get root node from heap array\r\n        let root = this.heapArray[0];\r\n\r\n        //Get last node in heap array and place it at the start of the array\r\n        const lastNode = this.heapArray[this.size -1];\r\n        this.heapArray[0] = lastNode;\r\n\r\n     \r\n\r\n        //Decrease size of heap by 1\r\n        this.size -= 1;\r\n        //Call heapify() to re-organize array to fit minheap requirements\r\n        this.heapify(0);\r\n        \r\n        //Return the new root value\r\n        return root;\r\n    }\r\n\r\n    decreaseKey(node, dist){\r\n\r\n        //Find location of given node in heap array\r\n        console.log(node)\r\n        let index = this.heapArray.findIndex((key) => (key[0].row === node.row && key[0].col === node.col));  \r\n\r\n        //Find index of parent using minheap property\r\n        let parentIndex = Math.floor((index-1)/2);\r\n\r\n        //Update distance value of given node\r\n        this.heapArray[index][1] = dist;\r\n\r\n        //If the new value is less than its parent, continually swap with parent until heap-order consition is met\r\n        while(index > 0 && this.heapArray[index][1] < this.heapArray[parentIndex][1]){\r\n\r\n            //Swap both nodes in heap array\r\n            this.swapHeapNode(index, parentIndex)\r\n\r\n            //Set the index to the parent index to check for failed condition again at top of loop\r\n            index = parentIndex;\r\n            parentIndex = Math.floor((index-1)/2);\r\n        }    \r\n    }\r\n\r\n/*\r\n    isInHeap(vertex){\r\n        \r\n        //If the given vertex is in the heap, return true. False otherwise\r\n        \r\n        if(this.pos(vertex) < this.size){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    \r\n    addNode(newNode){\r\n\r\n    }\r\n    */\r\n\r\n\r\n\r\n}","import MinHeap from './minHeap'\r\n\r\n//TODO: Deal with tracking rows and columns of nodes within minheap ( or outside)\r\n\r\nexport function Dijkstra(grid, startCoords, finishCoords){\r\n\r\n    //Decompose start and finish coordinates\r\n    const startRow = startCoords[0];\r\n    const startCol = startCoords[1];\r\n    const finishRow = finishCoords[0];\r\n    const finishCol = finishCoords[1];\r\n\r\n    // Create instance of minheap \r\n    let heap = new MinHeap();\r\n\r\n    //Create array to track visited nodes in order of visitation\r\n    let orderedVisitedNodes = [];\r\n\r\n    //Get the node objects for the start node and end node\r\n    const startNode = grid[startRow][startCol];  \r\n\r\n\r\n    //Create new heap Node for starting node(see attributes in minHeap class), and add this node to heap array with distance of 0\r\n    const startHeapNode = heap.newHeapNode(startNode, 0);\r\n    heap.addHeapNode(startHeapNode);\r\n\r\n    //Initialize Minheap\r\n    for(const curr_row of grid){\r\n        for(const node of curr_row){\r\n            //Start node has already been added to heap, so skip this iteration\r\n            if(node.row === startRow && node.col === startCol){\r\n                continue;\r\n            }\r\n            //Add node to the heap array\r\n            let heapNode = heap.newHeapNode(node, Infinity);\r\n            heap.addHeapNode(heapNode);     \r\n        }\r\n    }\r\n\r\n    //run algorithm while minheap still has nodes \r\n    //(break when finsh node is found)\r\n    while(heap.size !== 0){\r\n\r\n        //Get nearest node and decompose into node part and distance value\r\n        let closestNode = heap.extractMin(); //returns [node,distance]\r\n        let nodePart = closestNode[0];\r\n        const distance = closestNode[1];\r\n        \r\n\r\n        //Create isVisited property and set it to true\r\n        nodePart.isVisited = true;\r\n\r\n        //Add this node to array of visited nodes\r\n        orderedVisitedNodes.push(nodePart);\r\n\r\n        //If closest node is the finish node, stop algorithm\r\n        if(nodePart.row === finishRow && nodePart.col === finishCol){\r\n            break;\r\n        } \r\n        \r\n        //get the unvisited neighbors of current node (up, down, left, right)\r\n        let neighbors = getNeighbors(grid, nodePart);\r\n\r\n\r\n        //For each unvisited neighbor, set its distance to the current distance + 1\r\n        for(const neighbor of neighbors){\r\n            neighbor.prevNode = nodePart\r\n            heap.decreaseKey(neighbor, distance + 1);  \r\n        }\r\n\r\n\r\n    }\r\n    //Get last node visited (finish node)\r\n    const lastNode = orderedVisitedNodes.pop();\r\n    //Get shortest path from backTrack() function\r\n    const shortestPath = backTrack(lastNode, startRow, startCol);\r\n    //Once algorithm has finished, return shortest path from finish to start\r\n    return ([orderedVisitedNodes, shortestPath])   \r\n    \r\n\r\n}\r\n\r\nfunction getNeighbors(grid, node){\r\n    /*\r\n    Gets the four neighbors surrounding a node (up,down,left,right) which are unvisited\r\n    Args:\r\n    grid, Array: The grid of nodes\r\n    node, Node: The node whose neighbors will be returned\r\n    Returns:\r\n    neighbors: Array of all unvisited neighbor nodes \r\n    */\r\n\r\n    //Initialize neighbors as empty array\r\n    let neighbors = [];\r\n    //Get coordinates of node\r\n    const [row, col] = [node.row, node.col];\r\n\r\n    //If neighbor is on board, append to neighbors array\r\n    if (row<24){neighbors.push(grid[row+1][col])};\r\n    if (row>0){neighbors.push(grid[row-1][col])};\r\n    if (col<59){neighbors.push(grid[row][col+1])};\r\n    if (col>0) {neighbors.push(grid[row][col-1])};\r\n    //console.log(neighbors)\r\n    \r\n    //Remove neighbors which are walls\r\n    let filteredNeighbors = neighbors.filter(neighbor => !neighbor.isWall)\r\n\r\n    //Return all neighbors that haven't already been visited\r\n    return filteredNeighbors.filter(neighbor => !neighbor.isVisited)\r\n}\r\n\r\nexport function backTrack(lastNode, startRow, startCol){\r\n    //Initialize shortest path as empty array\r\n    const shortestPath = [];\r\n\r\n    //Current node starts as the finish node\r\n    let currNode = lastNode\r\n\r\n    //Get coordinates of finish node\r\n    let currentRow = lastNode.row;\r\n    let currentCol = lastNode.col;\r\n\r\n    //Append finish node to shortest path\r\n    shortestPath.push(currNode);\r\n\r\n    //Append each node to shortest path until start node is reached\r\n    while(currentRow !== startRow || currentCol !== startCol){\r\n        //Get previous node\r\n        currNode = currNode.prevNode\r\n        //Reset current coordinates to those of previous node\r\n        currentRow = currNode.row;\r\n        currentCol = currNode.col;\r\n        //Append previoud node to shortest path\r\n        shortestPath.push(currNode);\r\n    }\r\n    //Return shortest path form finish to start\r\n    return shortestPath;\r\n}\r\n","import MinHeap from './minHeap'\r\n\r\nexport default function aStar(grid, startCoords, finishCoords){\r\n\r\n    //Get row and column of the start node and finish node\r\n    const startRow = startCoords[0];\r\n    const startCol = startCoords[1];\r\n    const finishRow = finishCoords[0];\r\n    const finishCol = finishCoords[1];\r\n\r\n    //Get the start and finish node objects from grid\r\n    let startNode = grid[startRow][startCol];\r\n\r\n    //Initialize open list and closed list, \r\n    //open list is minheap of nodes to be visited, closed list is nodes that have already been visited\r\n    let openList = new MinHeap();\r\n\r\n    //open list is list of nodes to be visited, closed list is nodes that have alreadt been visited\r\n    let closedList = [];\r\n\r\n    //Create new heap Node for starting node(see attributes in minHeap class), and add this node to heap array with distance of 0\r\n    const startHeapNode = openList.newHeapNode(startNode, 0);\r\n    openList.addHeapNode(startHeapNode);\r\n\r\n    //Initialize Minheap\r\n    for(const curr_row of grid){\r\n        for(const node of curr_row){\r\n            //Start node has already been added to heap, so skip this iteration\r\n            if(node.row === startRow && node.col === startCol){\r\n                continue;\r\n            }\r\n            //Add node to the heap array\r\n            let heapNode = openList.newHeapNode(node, Infinity);\r\n            openList.addHeapNode(heapNode);     \r\n        }\r\n    }\r\n\r\n    //Continually search until openList is empty or finish point is found\r\n    while (openList.size !== 0){\r\n\r\n        //Set the current node to the first node in open list, and mark this node as visited\r\n        let closestNode = openList.extractMin(); //Returns [node, f] \r\n        let currNode = closestNode[0];\r\n        currNode.isVisited = true;\r\n\r\n        //Add current node to closed list\r\n        closedList.push(currNode)\r\n\r\n        //If the finish node has been found, break out of loop\r\n        if (currNode.row === finishRow && currNode.col === finishCol){\r\n            break;\r\n        }\r\n\r\n        //Get neighbors of the current node\r\n        let neighbors = getNeighbors(grid, currNode);\r\n        \r\n        //for each neighbor, calculate its value and add to open list\r\n        for(const neighbor of neighbors){\r\n            \r\n            // assign the current node as the previous node of the neighbor node\r\n            neighbor.prevNode = currNode;\r\n            const neighborCoords = [neighbor.row, neighbor.col];\r\n\r\n            //Calculate the Manhattan heuristic of the neighbor \r\n            const h = hueristic(neighborCoords, finishCoords);\r\n            const f = 1 + h;\r\n\r\n            //Change f value for neighbor in openList(minHeap)\r\n            openList.decreaseKey(neighbor, f)\r\n        }\r\n    }\r\n\r\n    //Once loop has finished, find the shortest path with backtrack\r\n    const lastNode = closedList.pop();\r\n    const shortestPath = backTrack(lastNode, startRow, startCol);\r\n\r\n    //Return the list of visited nodes in order (closed list) and the shortest path\r\n    return ([closedList, shortestPath])   \r\n\r\n\r\n}\r\n\r\nfunction hueristic(currCoords, finishCoords){\r\n    //Implement Manhattan hueristic\r\n\r\n    const h = Math.abs(currCoords[0] - finishCoords[0]) + Math.abs(currCoords[1] - finishCoords[1]);\r\n    return h;\r\n\r\n}\r\n\r\nfunction getNeighbors(grid, currNode){\r\n    //Return all eligbile neighbors of given node\r\n    let neighbors = [];\r\n    const [row, col] = [currNode.row, currNode.col];\r\n\r\n    //If neighbor is on board, append to neighbors array\r\n    if (row<24){neighbors.push(grid[row+1][col])};\r\n    if (row>0){neighbors.push(grid[row-1][col])};\r\n    if (col<59){neighbors.push(grid[row][col+1])};\r\n    if (col>0) {neighbors.push(grid[row][col-1])};\r\n\r\n    console.log(neighbors)\r\n\r\n    //Add filter for nodes already visited? Or is this solved by closed list??\r\n\r\n    //Remove neighbors which are walls\r\n    let filteredNeighbors = neighbors.filter(neighbor => !neighbor.isWall)\r\n\r\n    //Return all neighbors that haven't already been visited\r\n    //console.log(neighbors)\r\n    return filteredNeighbors.filter(neighbor => (!neighbor.isVisited && !neighbor.isStart))\r\n\r\n}\r\n\r\nexport function backTrack(lastNode, startRow, startCol){\r\n    //Initialize shortest path as empty array\r\n    const shortestPath = [];\r\n\r\n    //Current node starts as the finish node\r\n    let currNode = lastNode\r\n\r\n    //Get coordinates of finish node\r\n    let currentRow = lastNode.row;\r\n    let currentCol = lastNode.col;\r\n\r\n    //Append finish node to shortest path\r\n    shortestPath.push(currNode);\r\n\r\n    //Append each node to shortest path until start node is reached\r\n    while(currentRow !== startRow || currentCol !== startCol){\r\n        //Get previous node\r\n        currNode = currNode.prevNode\r\n        //Reset current coordinates to those of previous node\r\n        currentRow = currNode.row;\r\n        currentCol = currNode.col;\r\n        //Append previoud node to shortest path\r\n        shortestPath.push(currNode);\r\n    }\r\n    //Return shortest path form finish to start\r\n    return shortestPath;\r\n}","import React, { useState, useEffect, useCallback } from 'react';\r\nimport Node from './GridNode';\r\nimport './pathViz.css';\r\nimport { Dijkstra } from '../Algorithms/dijkstra';\r\nimport aStar  from '../Algorithms/aStar';\r\nimport GridNode from './GridNode';\r\n\r\n\r\nexport default function PathViz(){\r\n/*\r\nFunctional component which displays the entire Path visualizer\r\n*/\r\n\r\n//Initialize various state variables to be updated\r\n    const [grid, setGrid] = useState([]); //Grid to be displayed\r\n\r\n    //Tracks which instruction the next mouse click will perform\r\n    const [instr, setInstr] = useState(\"Start Point\")\r\n\r\n    //Tracks start and finish coordinates\r\n    const [startCoords, setStartCoords] = useState({});\r\n    const [finishCoords, setFinishCoords] = useState([]);\r\n\r\n    //Track if mouse is currently pressed\r\n    const [isClicked, setisClicked] = useState(false);\r\n\r\n    //Track algorithm to be used\r\n    const [algo, setAlgo] = useState(\"Dijkstra\")\r\n    \r\n    //0: slow, 1:medium, 2: fast\r\n    const [speed, setSpeed] = useState(1)\r\n\r\n    //Track status of animation and board\r\n    const [isFinding, setisFinding] = useState(false)\r\n    const [isReset, setisReset] = useState(true)\r\n\r\n\r\n    const createNode = (col, row) => {\r\n        /*\r\n        Returns an object with the properties for a blank node\r\n        */\r\n        return(\r\n            {\r\n            col, \r\n            row, \r\n            isStart: false, \r\n            isFinish: false, \r\n            isWall: false,\r\n            isVisited: false,\r\n            toBeReset: false\r\n            }\r\n        )\r\n    }\r\n\r\n    const gridInit = (row_dim, col_dim) => {\r\n        /*\r\n        Creates a blank grid with the given dimensions\r\n        Args:\r\n        row_dim, int: Specifies number of rows to be created on grid\r\n        col_dim, int: Specifies number of columns to be created on grid\r\n\r\n        Returns:\r\n        init_grid, array: An r x c array with plain nodes in each element\r\n        */\r\n\r\n        //Initialize grid as empty array\r\n        const init_grid = [];\r\n\r\n        //Create the grid one row at a time\r\n        for (let row = 0; row < row_dim; row++){\r\n\r\n            //Initialize current row as empty array\r\n            const curr_row = [];\r\n\r\n            //Append new nodes to the current row\r\n            for ( let col = 0; col < col_dim; col++){\r\n                const newNode = createNode(col,row);\r\n                curr_row.push(newNode);\r\n            }\r\n            //Append current row to grid\r\n            init_grid.push(curr_row); \r\n        }\r\n        return init_grid;\r\n    };\r\n\r\n    const handleClick = useCallback(function handleClick(e){\r\n        /*\r\n        Updates the grid when a node is clicked based on the current state\r\n        Args:\r\n        row,col: int: coordinates of node which was clicked\r\n        Returns: None\r\n        */\r\n\r\n        //Get coordinates of node clicked from event dataset\r\n       const row = e.currentTarget.dataset[\"row\"];\r\n       const col = e.currentTarget.dataset[\"col\"];\r\n          \r\n       //Execute code nested in setInstr in order to avoid handleClick updating and re-rendering all nodes\r\n        setInstr((prevInstr) => {\r\n            //If the previous instruction is start point\r\n            if (prevInstr === \"Start Point\") {\r\n                //Update grid with new start point\r\n                setGrid( (prevGrid) => {\r\n                    const updated_grid = prevGrid.slice();\r\n    \r\n                    //Get the current node at the given location\r\n                    const curr_node = updated_grid[row][col];\r\n    \r\n                    //Toggle isStartset for the current node\r\n                    const new_node = {...curr_node, isStart:true};\r\n    \r\n                    //Assign this new node to the correct location\r\n                    updated_grid[row][col] = new_node;\r\n                    return updated_grid\r\n                })\r\n                //Set start coords with position of current node\r\n                setStartCoords(() => {\r\n                    return [parseInt(row), parseInt(col)]\r\n                });\r\n                //Set state of mouse to not clicked\r\n                setisClicked(false)\r\n                //Update instruction to \"finish point\"\r\n                return (\"Finish Point\")\r\n            }\r\n            //If the start was already set\r\n            else if (prevInstr === \"Finish Point\"){\r\n                   \r\n                //Update state of grid, isClicked and finish coordinates\r\n                setGrid( (prevGrid) => {\r\n                    const updated_grid = prevGrid.slice();\r\n    \r\n                    //Get the current node at the given location\r\n                    const curr_node = updated_grid[row][col];\r\n    \r\n                    //Toggle isStartset for the current node\r\n                    const new_node = {...curr_node, isFinish:true};\r\n    \r\n                    //Assign this new node to the correct location\r\n                    updated_grid[row][col] = new_node;\r\n                    return updated_grid\r\n                })\r\n               //Set finish coords with coords of clicked node      \r\n                setFinishCoords(() => {\r\n                    return [parseInt(row), parseInt(col)]\r\n                });\r\n                //Set is clicked to false\r\n                setisClicked(false)\r\n                //Return new instruction as walls\r\n                return (\"Walls\")\r\n            }\r\n            else{\r\n                setisClicked(false)\r\n                return prevInstr\r\n            }\r\n        })\r\n    }, [])\r\n\r\n    const handleReset = () => {\r\n        /*\r\n        Resets the grid \r\n        */ \r\n\r\n       //Create new blank grid with gridInit() method.\r\n        const reset_grid = gridInit(25,60);\r\n\r\n        //Update states accordingly\r\n        setisReset(true)\r\n        setGrid(reset_grid);\r\n        setInstr(\"Start Point\")\r\n    }\r\n\r\n    const handleAlgoStart = () => {\r\n        /*\r\n        Start the algorithm and update the grid with the new path\r\n        */\r\n        //const [visitedPath, path] = Dijkstra(grid, startCoords, finishCoords);\r\n\r\n        setisFinding(true)\r\n        setisReset(false)\r\n\r\n        let [visitedPath, path] = [[], []];\r\n        switch(algo){\r\n            case \"Dijkstra\":\r\n                [visitedPath, path] = Dijkstra(grid, startCoords, finishCoords);\r\n                break;\r\n            case \"aStar\":\r\n                [visitedPath, path] = aStar(grid, startCoords, finishCoords);\r\n                break;\r\n            default: [visitedPath, path] = aStar(grid, startCoords, finishCoords);\r\n\r\n        }\r\n\r\n        let animateTime = 15;\r\n        switch(speed){\r\n            case 0:\r\n                animateTime = 50\r\n                break;\r\n            case 1:\r\n                animateTime = 20\r\n                break;\r\n            case 2:\r\n                animateTime = 5\r\n                break;\r\n            default:\r\n                animateTime = 20;\r\n        }\r\n\r\n        let new_grid = grid.slice();\r\n        //Update the each node visited by Djikstra's algorithm\r\n        for(let i = 1; i < visitedPath.length; i++){\r\n            const thisNode = visitedPath[i];\r\n            //Update each node with an asyncronous call every 10 ms (See updateVisited())\r\n            updateVisited(thisNode, i, animateTime)\r\n\r\n            //Update new_grid, to be used to update state\r\n            const row = thisNode.row;\r\n            const col = thisNode.col;\r\n            let curr_node = new_grid[row][col]\r\n            const new_node = {...curr_node, toBeReset:!curr_node.toBeReset};\r\n            new_grid[row][col] = new_node\r\n        }\r\n\r\n\r\n        // Update the path as soon as the animation has finished\r\n        setTimeout( () => {\r\n            updatePath(path)\r\n            setisFinding(false)\r\n        }, animateTime * visitedPath.length, path)\r\n\r\n        //Update the grid, this takes place before most of the animations \r\n        setGrid(new_grid)\r\n    }\r\n\r\n    const updatePath = (path) => {\r\n        //Update the path by creating a new grid and updating state\r\n        let new_grid = grid.slice();\r\n        for (let i = 0; i < path.length; i++){\r\n            const thisNode = path[i];\r\n            const row = thisNode.row;\r\n            const col = thisNode.col;\r\n            let curr_node = new_grid[row][col]\r\n            const new_node = {...curr_node, isPath:!curr_node.isPath};\r\n            new_grid[row][col] = new_node\r\n        }\r\n        setGrid(new_grid)\r\n    }      \r\n\r\n\r\n    const updateVisited = (pathNode, i, animateTime) => {\r\n        //Animate visited nodes every 10 ms\r\n\r\n        const row = pathNode.row;\r\n        const col = pathNode.col;\r\n        \r\n        setTimeout( () => {\r\n            document.getElementById(`row-${row}col-${col}`).className='node-visited'\r\n        }, animateTime*i, row, col)  \r\n    }\r\n\r\n    const handleWallSet = useCallback( function handleWallSet(e){\r\n        //Set status of mouse click to true\r\n        setisClicked(() => {\r\n            return true\r\n        });\r\n        //Call handleWallDrag to ensure the initial clicked node also is set as wall\r\n        handleWallDrag(e)\r\n    },[])\r\n\r\n    const handleWallDrag = useCallback( function handleWallDrag(e){\r\n        /*\r\n        Set walls on grid given the current state of the grid and mouse click\r\n        */\r\n\r\n        //Get coordinates of node entered with synthetic event\r\n        const row = e.currentTarget.dataset[\"row\"];\r\n        const col = e.currentTarget.dataset[\"col\"];\r\n        \r\n        //Nest all operations within setisClicked and setInstr in order to check those states\r\n        setisClicked( (prevClick) => {\r\n            //If the mouse is pressed\r\n            if (prevClick){\r\n                //Check if instruction is set to walls\r\n                setInstr( (prevInstr) => {\r\n                    if (prevInstr===\"Walls\"){\r\n                        //If walls are being set, set current node to a wall and update grid\r\n                        setGrid((prevGrid) => {\r\n                            const wallGrid = prevGrid.slice();\r\n                            const curr_node = wallGrid[row][col];\r\n                            const new_node = {...curr_node, isWall:true};\r\n                            wallGrid[row][col] = new_node;\r\n                            return wallGrid\r\n                        });\r\n                    }   \r\n                    //Return the same instruction as before, should only be reset with reset button                 \r\n                    return prevInstr\r\n                })\r\n                //Return mouse clicked as true\r\n                return true\r\n            }\r\n            //If mouse isn't pressed down, return previous instruction\r\n            else{\r\n                setInstr(prevInstr => {\r\n                    return prevInstr\r\n                })\r\n            }\r\n            //Always return mouse clicked as same value as previous state\r\n            return prevClick\r\n        })\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        /*\r\n        Updates the grid at the initial DOM render\r\n        Similar to componentdidMount() with React class component\r\n        */\r\n        const initial_grid = gridInit(25,60);\r\n        setGrid(initial_grid);\r\n    },[]); //rendered on only initial render because of empty array dependency\r\n\r\n    //Component rendering\r\n    return(\r\n        <div>\r\n        <div className=\"menu\">\r\n            <div className=\"options\">\r\n                <div className=\"options\">\r\n                    <p className=\"navbarText\">Algorithm:</p>\r\n                    <button className=\"algoButton\" style={{fontWeight: algo === \"Dijkstra\" ? \"bolder\" : \"inherit\", background: algo === \"Dijkstra\" ? \"blue\": \"inherit\", fontSize: algo === \"Dijkstra\" ? \"120%\": \"inherit\"}} onClick = {() => setAlgo(\"Dijkstra\")}>\r\n                        Dijkstra's \r\n                    </button>\r\n                    <button className=\"algoButton\" style={{fontWeight: algo === \"aStar\" ? \"bolder\" : \"inherit\", background: algo === \"aStar\" ? \"blue\": \"inherit\", fontSize: algo === \"aStar\" ? \"120%\": \"inherit\"}} onClick = {() => setAlgo(\"aStar\")}>\r\n                        A * Search\r\n                    </button>\r\n                </div>\r\n                <div className=\"options\">\r\n                    <p className=\"navbarText\">Animation speed: </p>\r\n                    <button className=\"algoButton\" style={{fontWeight: speed === 0 ? \"bolder\" : \"inherit\", background: speed === 0 ? \"blue\": \"inherit\", fontSize: speed === 0 ? \"120%\": \"inherit\"}} onClick={ () => setSpeed(0)} disabled={isFinding}>\r\n                        Slow\r\n                    </button>\r\n                    <button className=\"algoButton\" style={{fontWeight: speed === 1 ? \"bolder\" : \"inherit\", background: speed === 1 ? \"blue\": \"inherit\", fontSize: speed === 1 ? \"120%\": \"inherit\"}} onClick={ () => setSpeed(1)} disabled={isFinding}>\r\n                        Medium\r\n                    </button>\r\n                    <button className=\"algoButton\" style={{fontWeight: speed === 2 ? \"bolder\" : \"inherit\", background: speed === 2 ? \"blue\": \"inherit\", fontSize: speed === 2 ? \"120%\": \"inherit\"}} onClick={ () => setSpeed(2)} disabled={isFinding}>\r\n                        Fast\r\n                    </button>\r\n                </div>\r\n            </div>\r\n                \r\n            \r\n        </div>\r\n\r\n\r\n        <div className=\"grid\">\r\n            <text className=\"instructions\">Set {instr}</text>\r\n\r\n\r\n            <div className=\"options\">\r\n\r\n                <button className=\"reset\" onClick={() => handleReset()} disabled={isFinding}>\r\n                        Reset\r\n                    </button>\r\n                <button className=\"start\" onClick={() => handleAlgoStart()} disabled={(!isReset || instr ===\"Start Point\" || instr ===\"Finish Point\")}>\r\n                        Start {algo}\r\n                    </button>\r\n                \r\n            </div>\r\n            <div className=\"legend\">\r\n            <GridNode isStart={true}></GridNode>\r\n            <p className=\"legendText\">Start Point </p>\r\n            <GridNode isFinish={true}></GridNode>\r\n            <p className=\"legendText\">Finish Point </p>\r\n            <GridNode isWall={true}></GridNode>\r\n            <p className=\"legendText\">Wall </p>\r\n            <GridNode isVisited={true}></GridNode>\r\n            <p className=\"legendText\">Visited </p>\r\n            <GridNode isPath={true}></GridNode>\r\n            <p className=\"legendText\">Path </p>\r\n        </div>\r\n            \r\n            {grid.map( (row, rowIndex) => {\r\n                return(\r\n                    <div className=\"row\" key={rowIndex}>\r\n                        {row.map( (node, nodeIndex) => {\r\n                            const {col, row, isFinish, isStart, isWall, isPath, isVisualized, toBeReset} = node;\r\n                            return(\r\n                                <div key={nodeIndex} >\r\n                                    <Node \r\n                                        col = {col}\r\n                                        row = {row}\r\n                                        isFinish = {isFinish}\r\n                                        isStart = {isStart}\r\n                                        isWall = {isWall}\r\n                                        isPath = {isPath}\r\n                                        toBeReset = {toBeReset}\r\n                                        isVisualized = {isVisualized}\r\n                                        onMouseUp = {handleClick}\r\n                                        onMouseDown = {handleWallSet}\r\n                                        onMouseEnter = {handleWallDrag}\r\n                                    ></Node>\r\n                                </div>\r\n                            );\r\n                        })}\r\n                    </div>\r\n                );\r\n            }\r\n        )}\r\n        \r\n        </div>\r\n        </div>\r\n    )\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport PathViz from './visualizer/pathViz';\r\n\r\nfunction App() {\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <PathViz></PathViz>\r\n    </div>\r\n  ); \r\n}\r\n \r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}